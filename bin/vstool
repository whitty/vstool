#!/usr/bin/ruby

require 'pathname'

#review this - ocra integration
#require 'ocratools'
#OcraTools.modify_facets_path

require 'vstool'
require 'gw_command'
require 'enumerator'
require 'timeout'

HAVE_WIN32OLE_ROT =  VsTool::gem_version_match('win32olerot', ">=0.0.2")
if HAVE_WIN32OLE_ROT then
  gem 'win32olerot', ">=0.0.2"    # require exception fix
  require 'win32olerot'
end

#exit if OcraTools.ocra_is_compiling?

def optional_project(args)
  args.push(nil)
end

def max_args(args, max)
  raise Command::CommandError.new("Unexpected extra parameters") if args.length > max
end

parser = Command::Toplevel.new("vstool", "0.1a") do |tl|
  config = VsTool::Config.new

  tl.block_command(:debug, "Start the debugger going - equivalent to 'go'") do |cmd|
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length < 1

      VsTool::DebugCommand.new(config).run(*args)
    end
  end

  tl.block_command(:forcebreak, "Continue restarting debugger until a break occurs") do |cmd|
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length < 1

      VsTool::RunToDebugBreak.new(config).run(*args)
    end
  end

  tl.block_command(:stop, "Stop the debugger and terminate any processes - equivalent to 'Terminate All'") do |cmd|
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length < 1

      VsTool::StopCommand.new(config).run(*args)
    end
  end

  tl.block_command(:ato_error, "Pop open atoError_.cpp ready for ATO_ABORT " +
                   "debugging and set breakpoints in " +
                   "atoCreateAbortStream_()'") do |cmd|
    view = nil
    cmd.parms do |opts|
      opts.on("--view [VIEW]", "Optionally override the view path for locating the AtoError files") do |v|
        view = v.to_s
      end
    end
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length < 1

      VsTool::AtoErrorCommand.new(view, config).run(*args)
    end
  end

  tl.block_command(:ato_abort, "Set breakpoints in atoCreateAbortStream_()'") do |cmd|
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length < 1

      VsTool::AtoAbortCommand.new(config).run(*args)
    end
  end

  tl.block_command(:pop, "Start visual studio and open any files given after the command") do |cmd|
    timeout = nil
    cmd.usage_suffix = "[files...]"
    cmd.parms do |opts|
      opts.on("--timeout [SECS]", Float, "number of seconds to attempt to load files for (allowance for VS to startup) default is 30 seconds") do |f|
        raise Command::CommandError.new("Negative timeouts not supported") if f < 0
        timeout = f
      end
    end
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length < 1

      VsTool::PopCommand.new(config, timeout).run(*args)
    end
  end

  tl.block_command(:breakpoint, "Add breakpoints") do |cmd|
    cmd.usage_suffix = "Breakpoint [...]"
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length == 1

      VsTool::BreakpointCommand.new(config).run(*args)
    end
  end

  tl.block_command(:attach, "Attach the debugger to a given process") do |cmd|
    cmd.usage_suffix = "Process"
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length == 1

      VsTool::AttachCommand.new(config).run(*args)
    end
  end

  tl.block_command(:detach, "Detach the debugger to a given process") do |cmd|
    cmd.usage_suffix = "Process"
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length == 1

      VsTool::DetachCommand.new(config).run(*args)
    end
  end

  tl.block_command(:open, "Load the given file into the editor window") do |cmd|
    cmd.usage_suffix = "File [...]"
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length == 1

      VsTool::OpenCommand.new(config).run(*args)
    end
  end

  tl.block_command(:build, "Build the solution - equivalent to 'Build Solution'") do |cmd|
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length < 1

      VsTool::BuildCommand.new(config).run(*args)
    end
  end

  tl.block_command(:project, "Build a project and all its dependencies") do |cmd|
    both = false
    configuration = nil
    cmd.usage_suffix = "Project"

    cmd.parms do |opts|
      opts.on("-c", "--configuration [CONFIGURATION]", "Specify a configuration name to build NOTE: omitting a configuration will build the current \"active\" configuration") do |v|
        configuration = v.to_s
      end

      opts.on("-b", "--both-configurations", "Build both \"Release\" and \"Debug\" configurations for each project") do |v|
        both = v
      end 
    end

    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length == 1

      VsTool::BuildProjectCommand.new(config,
                                      :both => both,
                                      :configuration => configuration).run(*args)
    end
  end
  
  tl.block_command(:configuration, "Get or set the active configuration (eg \"Release\" and \"Debug\")") do |cmd|
    cmd.usage_suffix = "Configuration"

    cmd.run do |args|

      # allow implicit solution
      if args.length == 0
        args = [nil]
      elsif args.length == 1
        args = [nil].concat(args) if args[0] !~ /\.(sln|exe)$/i
      end

      VsTool::ConfigurationCommand.new(config).run(*args)
    end
  end

  tl.block_command(:isopen, "Indicate if a given solution is running") do |cmd|
    cmd.run do |args|
      # allow implicit solution
      optional_project(args) if args.length < 1

      exit(VsTool::IsOpen.new(config).run(*args))
    end
  end

end
command = parser.parse(ARGV)
